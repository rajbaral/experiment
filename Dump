import {
  Component, OnDestroy, OnInit, ViewEncapsulation
} from '@angular/core';
import {
  FormControl, FormGroup, Validators
} from '@angular/forms';
import { Subscription } from 'rxjs';
import { UploadScanService } from '@shared/services/upload-scan/upload-scan.service';
import { FeatureFlagService } from '@shared/services/feature-flags/feature-flag.service';
import { UITKAlertService } from '@uitk/angular';
import { OptumSharedAuthService } from 'optum-shared-auth';
import { DynamsoftScannerService } from '@shared/services/dynamsoft-scanner/dynamsoft-scanner.service';
import { ConfigurationService } from '@shared/services/configuration-service/configuration.service';

@Component({
  selector: 'optum-dynamsoft-scan-document',
  templateUrl: './dynamsoft-scan-document.component.html',
  styleUrls: ['./dynamsoft-scan-document.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class DynamsoftScanDocumentComponent implements OnInit, OnDestroy {
  private readonly subscription = new Subscription();
  private pdfBlobUrl: string | null = null;

  isDynamsoftReady = false;
  scannedDocuments: { name: string; url: string; type: string }[] = [];
  scanMetadataList: { totalPages: number; scanType: string; isBatch: boolean; paperSource: string }[] = [];
  uploadProgressMap: { [fileName: string]: number } = {};

  scanDocumentsForm = new FormGroup({
    input: new FormControl('', Validators.required),
    multiSelect: new FormControl([{ label: 'Dental Claims', value: 'dental_claims' }])
  });

  grandTotalPages = 0;
  selectedPdfUrl: string | null = null;
  deleteWarningDialog = { show: false };
  retryWarningDialog = { show: false };
  pdfPreviewDialog = { show: false };
  isUploading = false;
  deleteIndex: number | null = null;

  constructor(
    private uploadScanService: UploadScanService,
    public featureFlagService: FeatureFlagService,
    private alertService: UITKAlertService,
    private authService: OptumSharedAuthService,
    private scannerService: DynamsoftScannerService,
    private configService: ConfigurationService
  ) {}

  get loggedIn(): boolean {
    return this.authService.isLoggedIn;
  }

  get username(): string {
    return this.authService.getUserName() ?? '';
  }

  ngOnInit(): void {
    this.subscription.add(
      this.authService.loginChanged.subscribe((isLoggedIn: boolean) => {
        if (!isLoggedIn) this.clearScans();
      })
    );

    this.scannerService.initialize('dwtcontrolContainer').then(() => {
      this.isDynamsoftReady = true;
    }).catch(err => this.showErrorMessage(err));
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
    this.clearPdfPreview();
  }

  acquireImage(): void {
    this.scannerService.acquireImage(
      () => this.processScannedPages(),
      (err) => this.showErrorMessage(err)
    );
  }

  processScannedPages(): void {
    const imageCount = this.scannerService.getImageCount();
    if (imageCount === 0) return this.showErrorMessage('No scanned images found.');

    const indices = Array.from({ length: imageCount }, (_, i) => i);
    this.scannerService.convertToPDFBlob(indices, (blob) => {
      this.addScannedDocument(blob, imageCount);
    }, (err) => this.showErrorMessage(err));
  }

  addScannedDocument(blob: Blob, pageCount: number): void {
    const reader = new FileReader();
    const sourceType = this.scanDocumentsForm.get('multiSelect')?.value?.[0]?.value ?? 'dental_claims';
    const name = `${sourceType}_${new Date().toISOString().split('T')[0]}_${this.scannedDocuments.length + 1}.pdf`;

    reader.onload = () => {
      this.scannedDocuments.push({ name, url: reader.result as string, type: 'application/pdf' });
      this.scanMetadataList.push({
        totalPages: pageCount,
        scanType: pageCount === 1 ? 'single' : 'multi',
        isBatch: false,
        paperSource: 'Scanner'
      });
      this.grandTotalPages += pageCount;
      this.showSuccessMessage(`Successfully scanned ${pageCount} page(s)`);
    };
    reader.readAsDataURL(blob);
  }

  stageScannedDocs(): void {
    this.scannerService.getScannedImagesAsBlobArray().then(blobs => {
      blobs.forEach((blob, index) => {
        const name = `scanned_document_${Date.now()}_${index}.pdf`;
        const reader = new FileReader();
        reader.onload = () => {
          this.scannedDocuments.push({ name, url: reader.result as string, type: 'application/pdf' });
        };
        reader.readAsDataURL(blob);
      });
    });
  }

  uploadScans(): void {
    if (!this.scanDocumentsForm.valid || !this.scannedDocuments.length) return;

    this.isUploading = true;
    const batchDescription = this.scanDocumentsForm.get('input')?.value;
    const sourceType = this.scanDocumentsForm.get('multiSelect')?.value?.[0]?.value ?? '';

    const uploads = this.scannedDocuments.map((doc, i) => {
      const fileName = doc.name;
      const base64 = doc.url.replace(/^data:application\/pdf;base64,/, '');
      const metadata = { ...this.scanMetadataList[i], batchDescription, sourceType, fileName };

      this.uploadProgressMap[fileName] = 0;

      return this.uploadScanService.uploadPdfInChunksWithProgress(
        base64,
        fileName,
        (p) => this.uploadProgressMap[fileName] = p,
        batchDescription,
        sourceType,
        metadata
      ).catch(() => false);
    });

    Promise.all(uploads).then(results => {
      this.isUploading = false;
      if (results.every(Boolean)) {
        this.scanDocumentsForm.reset();
        this.scannedDocuments = [];
        this.scanMetadataList = [];
        this.grandTotalPages = 0;
        this.showSuccessMessage('Upload successful!');
      } else {
        this.retryWarningDialog.show = true;
      }
    });
  }

  openPdfPreview(dataUrl: string): void {
    this.clearPdfPreview();
    this.pdfBlobUrl = this.dataURLToBlobUrl(dataUrl);
    this.selectedPdfUrl = this.pdfBlobUrl;
    this.pdfPreviewDialog.show = true;
  }

  clearPdfPreview(): void {
    if (this.pdfBlobUrl) {
      URL.revokeObjectURL(this.pdfBlobUrl);
      this.pdfBlobUrl = null;
    }
    this.selectedPdfUrl = null;
  }

  clearScans(): void {
    this.scannedDocuments = [];
    this.scanMetadataList = [];
    this.grandTotalPages = 0;
    this.scannerService.clearImages();
  }

  confirmDelete(): void {
    if (this.deleteIndex !== null) {
      this.scannedDocuments.splice(this.deleteIndex, 1);
      this.scanMetadataList.splice(this.deleteIndex, 1);
      this.grandTotalPages = this.scanMetadataList.reduce((sum, meta) => sum + meta.totalPages, 0);
    }
    this.deleteWarningDialog.show = false;
    this.deleteIndex = null;
  }

  dataURLToBlobUrl(dataUrl: string): string {
    const [prefix, base64] = dataUrl.split(',');
    const mime = prefix.match(/:(.*?);/)?.[1] ?? 'application/pdf';
    const bin = atob(base64);
    const u8arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) u8arr[i] = bin.charCodeAt(i);
    return URL.createObjectURL(new Blob([u8arr], { type: mime }));
  }

  retryUploadFromDialog(): void {
    this.retryWarningDialog.show = false;
    this.uploadScans();
  }

  private showSuccessMessage(msg: string) {
    this.alertService.showNotification({ id: 'success-alert', variant: 'success', content: msg, duration: 4000 });
  }

  private showErrorMessage(msg: string) {
    this.alertService.showNotification({ id: 'error-alert', variant: 'info', content: msg, duration: 5000 });
  }

  openConfirmDeleteDialog(index: number): void {
    this.deleteIndex = index;
    this.deleteWarningDialog.show = true;
  }

  cancelBtnConfirmDeleteDialog(): void {
    this.deleteWarningDialog.show = false;
    this.deleteIndex = null;
  }

  closePdfPreview(): void {
    this.pdfPreviewDialog.show = false;
    this.clearPdfPreview();
  }

  failureRetryCloseDialog(): void {
    this.retryWarningDialog.show = false;
  }

  get showScanner(): boolean {
    return this.featureFlagService.isScannerJsEnabled;
  }
}
